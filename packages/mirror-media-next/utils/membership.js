import { auth } from '../firebase'
import { signOut } from 'firebase/auth'

/**
 * @typedef {import('../context/membership').Membership['accessToken']} AccessToken
 */
import client from '../apollo/apollo-client'

import { fetchAllMember } from '../apollo/membership/query/member'
import { createMember } from '../apollo/membership/mutation/member'
import axios from 'axios'
import { API_TIMEOUT, WEEKLY_API_SERVER_ORIGIN } from '../config/index.mjs'
/**
 * there are 3 error situation:
 * 1: has firebase auth, but no member data in Israfel(login)
 * 2: has created new firebase auth, but member email is duplicated (regiser)
 * 3: some server error
 * in situation 1 and 2:
 * we need to delete this member's firebase account
 * in situation3:
 * do nothing with the firebase auth object
 * @param {Error | import('firebase/app').FirebaseError} error
 */
const errorHandler = async (error) => {
  if (
    error?.message === "GraphQL error: Can't find data in Israfel" ||
    error?.message === "this member's email has been used in Israfel"
  ) {
    const currentUser = auth.currentUser
    currentUser.delete()
  }
  console.error(error)
  //TODO: send log
  await signOut(auth)
  //TODO: firebase logout
}

/**
 *
 * @param {AccessToken} accessToken
 * @param {string} email
 * @param {string} firebaseId
 */
const createMemberDataInIsrafel = async (accessToken, email, firebaseId) => {
  try {
    const result = await client.mutate({
      mutation: createMember,
      context: {
        uri: '/member/graphql',
        headers: {
          authorization: accessToken ? `Bearer ${accessToken}` : '',
        },
      },
      variables: {
        firebaseId: firebaseId,
        email: email,
      },
    })
    return result
  } catch (error) {
    const errorMessage =
      error.message.search('Unique constraint failed on the fields') !== -1
        ? "this member's email has been used in Israfel"
        : error.message

    throw new Error(errorMessage)
  }
}
const fetchBasicMemberInfoInIsrafel = async (firebaseUid) => {
  try {
    const result = await client.query({
      query: fetchAllMember,
      context: { uri: '/member/graphql' },
      variables: {
        firebaseId: firebaseUid,
      },
    })
    const memberData = result?.data?.member
    if (!memberData) {
      throw "GraphQL error: Can't find data in Israfel, please check if this member's data existed in Israfel"
    }
    return memberData
  } catch (error) {
    throw new Error(error)
  }
}

const getAccessToken = async (idToken) => {
  try {
    const res = await axios({
      method: 'post',
      url: `https://${WEEKLY_API_SERVER_ORIGIN}/access-token`,
      headers: {
        authorization: `Bearer ${idToken}`,
      },
      timeout: API_TIMEOUT,
    })
    const accessToken = res?.data?.data['access_token'] //
    return accessToken
  } catch (error) {
    const statusCode = error?.response?.status
    let errorMessage = ''
    switch (statusCode) {
      case 401:
        errorMessage = 'Firebase ID token has invalid signature'
      case 500:
        errorMessage =
          'Unexpected error occur when getting Access token generated by Israfel'
      default:
        errorMessage =
          'Unexpected error occur when getting Access token generated by Israfel'
    }
    throw new Error(errorMessage)
  }
}

const loginPageOnAuthStateChangeAction = async (
  firebaseAuthUser,
  mode,
  isNewUser,
  accessToken = ''
) => {
  try {
    if (!accessToken) {
      return
    }
    const userUid = firebaseAuthUser.uid
    const isRegister = mode === 'register' || isNewUser
    // step 1: if it is a new user(register or first login by 3 party login), create it member is israfel
    if (mode === 'register' || isNewUser) {
      const userEmail = firebaseAuthUser.email

      await createMemberDataInIsrafel(accessToken, userEmail, userUid)
    }

    // step 2: fetch its data from israfel
    if (userUid) {
      await fetchBasicMemberInfoInIsrafel(userUid)
    }
    const result = isRegister ? 'registerSuccess' : 'loginSuccess'
    return result
  } catch (error) {
    throw error
  }
}

export { errorHandler, loginPageOnAuthStateChangeAction, getAccessToken }
